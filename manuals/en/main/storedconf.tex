%%
%%

\chapter{Storage Daemon Configuration}
\label{StoredConfChapter}
\index[general]{Storage Daemon Configuration}
\index[general]{Configuration!Storage Daemon}

The Storage Daemon configuration file has relatively few resource definitions.
However, due to the great variation in backup media and system capabilities,
the storage daemon must be highly configurable. As a consequence, there are
quite a large number of directives in the Device Resource definition that
allow you to define all the characteristics of your Storage device (normally a
tape drive). Fortunately, with modern storage devices, the defaults are
sufficient, and very few directives are actually needed.

For a general discussion of configuration file and resources including the
data types recognized by {\bf Bareos}, please see the
\ilink{Configuration}{ConfigureChapter} chapter of this manual. The
following Storage Resource definitions must be defined:

\begin{itemize}
\item
   \ilink{Storage}{StorageResource} -- to define the  name of the
   Storage daemon.
\item
   \ilink{Director}{DirectorResource1} -- to  define the Director's
   name and his access password.
\item
   \ilink{Device}{DeviceResource} -- to define  the
   characteristics of your storage device (tape  drive).
\item
   \ilink{Messages}{MessagesChapter} -- to define where error  and
   information messages are to be sent.
\end{itemize}

Following resources are optional:
\begin{itemize}
\item
   \ilink{AutoChanger}{AutochangerRes} -- to define Autochanger devices.
\item
   \ilink{NDMP}{NDMPResource} -- to define the NDMP authentication
   context.
\end{itemize}

\section{Storage Resource}
\label{StorageResource}
\index[general]{Resource!Storage}
\index[general]{Storage Resource}

In general, the properties specified under the Storage resource define global
properties of the Storage daemon. Each Storage daemon configuration file must
have one and only one Storage resource definition.

\begin{description}

\directive{sd}{Name}{name}{required}{}{}
Specifies the Name of the Storage daemon.

\directive{sd}{Working Directory}{directory}{required}{{\it platform specific}}{}
This directive specifies a directory in which the Storage daemon may put
its status files. This directory should be used only  by {\bf Bareos},
but may be shared by other Bareos daemons provided the names given to each
daemon are unique.

\directive{sd}{Pid Directory}{directory}{required}{{\it platform specific}}{}
This directive specifies a directory in which the Storage Daemon may put its
process Id file files. The process Id file is used to  shutdown Bareos and to
prevent multiple copies of  Bareos from running simultaneously.
Standard shell expansion of the {\bf directory} is done when the
configuration file is read so that values such  as {\bf \$HOME} will be
properly expanded.

% \item [Subsys Directory = {\textless}Directory{\textgreater}] \hfill \\
% \index[sd]{Subsys Directory}
% \index[sd]{Directive!Subsys Directory}
% This directive is currently unused.

\directive{sd}{Plugin Directory}{directory}{required}{{\it platform specific}}{}
This directive specifies a directory in which the Storage Daemon searches for
plugins with the name {\bf {\textless}pluginname{\textgreater}-sd.so} which it will load at startup.

%\directive{sd}{Scripts Directory}{directory}{required}{{\it platform specific}}{}
%This directive is currently unused.

\directive{sd}{Heartbeat Interval}{time-interval}{required}{0}{}
\index[general]{Heartbeat Interval}
\index[general]{Broken pipe}
This directive defines an interval of time in seconds.  When
the Storage daemon is waiting for the operator to mount a
tape, each time interval, it will send a heartbeat signal to
the File daemon.  The default interval is zero which disables
the heartbeat.  This feature is particularly useful if you
have a router that does not follow Internet
standards and times out an valid connection after a short
duration despite the fact that keepalive is set.  This usually
results in a broken pipe error message.

\directive{sd}{Client Connect Wait}{time-interval}{required}{30 minutes}{}
\index[general]{Client Connect Wait}
This directive defines an interval of time in seconds that
the Storage daemon will wait for a Client (the File daemon)
to connect.  Be aware that the
longer the Storage daemon waits for a Client, the more
resources will be tied up.

\directive{sd}{Maximum Concurrent Jobs}{number}{required}{10}{}
where {\textless}number{\textgreater} is the maximum number of Jobs that may run
concurrently.  The default is set to 10, but you may set it to a larger
number.  Each contact from the Director (e.g.  status request, job start
request) is considered as a Job, so if you want to be able to do a {\bf
status} request in the console at the same time as a Job is running, you
will need to set this value greater than 1.  To run simultaneous Jobs,
you will need to set a number of other directives in the Director's
configuration file.  Which ones you set depend on what you want, but you
will almost certainly need to set the {\bf Maximum Concurrent Jobs} in
the Storage resource in the Director's configuration file and possibly
those in the Job and Client resources.

\directive{sd}{SD Adress}{IP-address}{}{}{}
This directive is optional, and if it is specified, it will cause the
Storage daemon server (for Director and File daemon connections) to bind
to the specified {\bf IP-Address}, which is either a domain name or an
IP address specified as a dotted quadruple.  If this directive is not
specified, the Storage daemon will bind to any available address (the
default).

\directive{sd}{SD Adresses}{IP-address-specification}{}{}{}
Specify the ports and addresses on which the Storage daemon will listen
for Director connections.  Normally, the default is sufficient and you
do not need to specify this directive.  Probably the simplest way to
explain how this directive works is to show an example:

\footnotesize
\begin{verbatim}
 SDAddresses  = { ip = {
        addr = 1.2.3.4; port = 1205; }
    ipv4 = {
        addr = 1.2.3.4; port = http; }
    ipv6 = {
        addr = 1.2.3.4;
        port = 1205;
    }
    ip = {
        addr = 1.2.3.4
        port = 1205
    }
    ip = {
        addr = 1.2.3.4
    }
    ip = {
        addr = 201:220:222::2
    }
    ip = {
        addr = bluedot.thun.net
    }
}
\end{verbatim}
\normalsize

where ip, ip4, ip6, addr, and port are all keywords. Note, that  the address
can be specified as either a dotted quadruple, or  IPv6 colon notation, or as
a symbolic name (only in the ip specification).  Also, port can be specified
as a number or as the mnemonic value from  the /etc/services file.  If a port
is not specified, the default will be used. If an ip  section is specified,
the resolution can be made either by IPv4 or  IPv6. If ip4 is specified, then
only IPv4 resolutions will be permitted,  and likewise with ip6.

Using this directive, you can replace both the SDPort and SDAddress
directives shown below.

\directive{sd}{SD Port}{port-number}{required}{9103}{}
Specifies port number on which the Storage daemon  listens for Director
connections.

\directive{sd}{Compatible}{yes{\textbar}no}{required}{yes}{}
This directive enables the compatible mode of the storage daemon. In
this mode the storage daemon will try to write the storage data in a
compatible way with Bareos of which Bareos is a fork. This only works
for the data streams both share and not for any new datastreams which
are Bareos specific. Which may be read when used by a Bareos storage
daemon but might not be understood by any of the Bareos components
(dir/sd/fd).

\directive{sd}{NDMP Enable}{yes{\textbar}no}{}{}{}
This directive enables the Native NDMP Tape Agent.

\directive{sd}{NDMP Snooping}{yes{\textbar}no}{}{}{}
This directive enables the Snooping and pretty printing of NDMP protocol
information in debugging mode.

\directive{sd}{NDMP Loglevel}{level}{}{}{}
This directive sets the loglevel for the NDMP protocol library.

\directive{sd}{NDMP Address}{IP-address}{}{}{}
This directive is optional, and if it is specified, it will cause the
Storage daemon server (for NDMP Tape Server connections) to bind
to the specified {\bf IP-Address}, which is either a domain name or an
IP address specified as a dotted quadruple.  If this directive is not
specified, the Storage daemon will bind to any available address (the
default).

\directive{sd}{NDMP Addresses}{IP-address-specification}{}{}{}
Specify the ports and addresses on which the Storage daemon will listen
for NDMP Tape Server connections.  Normally, the default is sufficient and you
do not need to specify this directive.

\directive{sd}{NDMP Port}{port-specification}{}{10000}{}
Specifies port number on which the Storage daemon listens for NDMP Tape Server
connections.

\xdirective{sd}{AutoXflateOnReplication}{yes{\textbar}no}{required}{yes}{13.4}{This directive controls the autoxflate-sd plugin when replicating data inside one or
between two storage daemons (Migration/Copy Jobs). Normally the storage daemon will
use the autoinflate/autodeflate setting of the device when reading and writing
data to it which could mean that while reading it inflates the compressed data
and the while writing the other deflates it again. If you just want the data to
be exactly the same e.g. don't perform any on the fly uncompression and compression
while doing the replication of data you can set this option to no and it will
override any setting on the device for doing auto inflation/deflation when doing
data replication. This will not have any impact on any normal backup or restore jobs.}
\end{description}

The following is a typical Storage daemon Storage definition.

\begin{bconfig}{Storage daemon Storage definition}
#
# "Global" Storage daemon configuration specifications appear
# under the Storage resource.
#
Storage {
  Name = "Storage daemon"
  Address = localhost
}
\end{bconfig}

\section{Director Resource}
\label{DirectorResource1}
\index[general]{Director Resource}
\index[general]{Resource!Director}

The Director resource specifies the Name of the Director which is permitted
to use the services of the Storage daemon.  There may be multiple Director
resources.  The Director Name and Password must match the corresponding
values in the Director's configuration file.

\begin{description}

\item [Name = {\textless}Director-Name{\textgreater}] \hfill \\
\index[sd]{Name}
\index[sd]{Directive!Name}
Specifies the Name of the Director allowed to connect  to the Storage daemon.
This directive is required.

\item [Password = {\textless}Director-password{\textgreater}] \hfill \\
\index[sd]{Password}
\index[sd]{Directive!Password}
Specifies the password that must be supplied by the above named  Director.
This directive is required.

\item [Monitor = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Monitor}
\index[sd]{Directive!Monitor}
If Monitor is set to {\bf no} (default), this director will have full
access to this Storage daemon.  If Monitor is set to {\bf yes}, this
director will only be able to fetch the current status of this Storage
daemon.

Please note that if this director is being used by a Monitor, we highly
recommend to set this directive to {\bf yes} to avoid serious security
problems.

\item [Key Encryption Key = {\textless}KeyEncryptionKey{\textgreater}] \hfill \\
\index[sd]{Key Encryption Key}
\index[sd]{Directive!Key Encryption Key}
This key is used to encrypt the Security Key that is exchanged between
the Director and the Storage Daemon for supporting Application Managed
Encryption (AME). For security reasons each Director should have a
different Key Encryption Key.

\end{description}

The following is an example of a valid Director resource definition:

\footnotesize
\begin{verbatim}
Director {
  Name = MainDirector
  Password = my_secret_password
}
\end{verbatim}
\normalsize

\label{NDMPResource}
\section{NDMP Resource}
\index[general]{Resource!NDMP}
\index[general]{NDMP Resource}

The NDMP Resource specifies the authentication details of each NDMP client.
There may be multiple NDMP resources for a single Storage daemon. In general,
the properties specified within the NDMP resource are specific to one client.

\begin{description}

\item [Name = {\textless}Client-Name{\textgreater}] \hfill \\
\index[sd]{Name}
\index[sd]{Directive!Name}
Specifies the name of the NDMP Client allowed to connect to the Storage daemon.
This directive is required.

\item [Username = {\textless}Client-Username{\textgreater}] \hfill \\
\index[sd]{Username}
\index[sd]{Directive!Username}
Specifies the username that must be supplied by the above named NDMP Client.
This directive is required.

\item [Password = {\textless}Client-password{\textgreater}] \hfill \\
\index[sd]{Password}
\index[sd]{Directive!Password}
Specifies the password that must be supplied by the above named NDMP Client.
This directive is required.

\item [Authtype = {\textless}Client-Authtype{\textgreater}] \hfill \\
\index[sd]{Authtype}
\index[sd]{Directive!Authtype}
Specifies the authentication type that must be supplied by the above named NDMP Client.
This directive is required.

The following values are allowed:
\begin{enumerate}
\item None - Use no password
\item Clear - Use clear text password
\item MD5 - Use MD5 hashing
\end{enumerate}

\item [Loglevel = {\textless}NDMP-Loglevel{\textgreater}] \hfill \\
\index[sd]{Loglevel}
\index[sd]{Directive!Loglevel}
Specifies the NDMP Loglevel which overrides the global NDMP loglevel for this client.

\end{description}

\label{DeviceResource}
\section{Device Resource}
\index[general]{Resource!Device}
\index[general]{Device Resource}

The Device Resource specifies the details of each device (normally a tape
drive) that can be used by the Storage daemon.  There may be multiple
Device resources for a single Storage daemon.  In general, the properties
specified within the Device resource are specific to the Device.

\begin{description}

\directive{sd}{Name}{name}{required}{}{}
Specifies the Name that the Director will use when asking to backup or
restore to or from to this device. This is the logical  Device name, and may
be any string up to 127 characters in length.  It is generally a good idea to
make it correspond to the English  name of the backup device. The physical
name of the device is  specified on the {\bf Archive Device} directive
described below.  The name you specify here is also used in your Director's
conf  file on the
\ilink{Device directive}{StorageResource2}  in its Storage
resource.

\directive{sd}{Archive Device}{device {\textbar} directory {\textbar} fifo}{required}{}{}
Specifies where to read and write the backup data.
The type of the Archive Device can be specified by the {\bf Device Type} directive.
If Device Type is not specified, Bareos tries to guess the Device Type
accordingly to the type of the specified Archive Device file type.

There are three different types that are supported:
\begin{description}
    \item[device] Usually the device file
name of a removable storage device (tape drive),  for example "{\bf
/dev/nst0}" or "{\bf /dev/rmt/0mbn}", preferably in the "non-rewind" variant.
In addition, on systems such as Sun, which have multiple tape
access methods, you must be sure to specify to use Berkeley I/O
conventions with the device.  The {\bf b} in the Solaris (Sun) archive
specification {\bf /dev/rmt/0mbn} is what is needed in this case.
Bareos does not support SysV tape drive behavior.
    \item[directory] If a directory is specified, it is used as file storage.
The directory must be existing and be specified as absolute path.
Bareos will write to file storage in the specified
directory and the filename used will be the Volume name as specified in the
Catalog.  If you want to write into more than one directory (i.e.  to spread
the load to different disk drives), you will need to define two Device
resources, each containing an Archive Device with a different directory.
    \item[fifo] \label{SetupFifo}
A FIFO is a special kind of file that  connects two programs
via kernel memory. If a FIFO device is specified  for a backup operation, you
must have a program that reads what Bareos  writes into the FIFO. When the
Storage daemon starts the job, it  will wait for {\bf MaximumOpenWait} seconds
for the read program to start reading, and then time it out and  terminate
the job. As a consequence, it is best to start the read  program at the
beginning of the job perhaps with the {\bf RunBeforeJob}  directive. For this
kind of device, you never want to specify  {\bf AlwaysOpen}, because you want
the Storage daemon to open it only  when a job starts, so you must explicitly
set it to {\bf No}.  Since a FIFO is a one way device, Bareos will not attempt
to read  a label of a FIFO device, but will simply write on it. To create a
FIFO Volume in the catalog, use the {\bf add} command rather than the {\bf
label} command to avoid attempting to write a label.
{
\footnotesize
\begin{verbatim}
Device {
  Name = FifoStorage
  Media Type = Fifo
  Device Type = Fifo
  Archive Device = /tmp/fifo
  LabelMedia = yes
  Random Access = no
  AutomaticMount = no
  RemovableMedia = no
  MaximumOpenWait = 60
  AlwaysOpen = no
}
\end{verbatim}
}
%\normalsize
During a restore operation, if the Archive Device is a FIFO, Bareos  will
attempt to read from the FIFO, so you must have an external program  that
writes into the FIFO. Bareos will wait {\bf MaximumOpenWait} seconds  for the
program to begin writing and will then time it out and  terminate the job. As
noted above, you may use the {\bf RunBeforeJob}  to start the writer program
at the beginning of the job.
\end{description}


\directive{sd}{Device Type}{tape {\textbar} file {\textbar} fifo}{}{}{}
The Device Type specification allows you to explicitly tell Bareos
what kind of device you are defining. It the {\bf type-specification}
may be one of the following:
\begin{description}
\item [Tape]
  The device is a tape device and thus is sequential access. Tape devices
  are controlled using ioctl() calls.
\item [File]
  Tells Bareos that the device is a file. It may either be a
  file defined on fixed medium or a removable filesystem such as
  USB.  All files must be random access devices.
\item [Fifo]
  The device is a first-in-first out sequential access read-only
  or write-only device.
\end{description}

The Device Type directive is not required, and if not specified, Bareos
will attempt to guess what kind of device has been specified using the
Archive Device specification supplied. There are several advantages to
explicitly specifying the Device Type. First, on some systems, block and
character devices have the same type.
Secondly, if you explicitly specify the Device Type, the mount point
need not be defined until the device is opened. This is the case with
most removable devices such as USB.
If the Device Type is not explicitly specified, then the mount point
must exist when the Storage daemon starts.



\item [Media Type = {\textless}name-string{\textgreater}] \hfill \\
\index[sd]{Media Type}
\index[sd]{Directive!Media Type}
The specified {\bf name-string} names the type of media supported by this
device, for example, "DLT7000".  Media type names are arbitrary in that you
set them to anything you want, but they must be known to the volume
database to keep track of which storage daemons can read which volumes.  In
general, each different storage type should have a unique Media Type
associated with it.  The same {\bf name-string} must appear in the
appropriate Storage resource definition in the Director's configuration
file.

Even though the names you assign are arbitrary (i.e.  you choose the name
you want), you should take care in specifying them because the Media Type
is used to determine which storage device Bareos will select during
restore.  Thus you should probably use the same Media Type specification
for all drives where the Media can be freely interchanged.  This is not
generally an issue if you have a single Storage daemon, but it is with
multiple Storage daemons, especially if they have incompatible media.

For example, if you specify a Media Type of "DDS-4" then during the
restore, Bareos will be able to choose any Storage Daemon that handles
"DDS-4".  If you have an autochanger, you might want to name the Media Type
in a way that is unique to the autochanger, unless you wish to possibly use
the Volumes in other drives.  You should also ensure to have unique Media
Type names if the Media is not compatible between drives.  This
specification is required for all devices.

In addition, if you are using disk storage, each Device resource will
generally have a different mount point or directory. In order for
Bareos to select the correct Device resource, each one must have a
unique Media Type.

\label{Autochanger}
\item [Autochanger = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Autochanger}
\index[sd]{Directive!Autochanger}
If {\bf Yes}, this device belongs to an automatic tape changer, and you
must specify an {\bf Autochanger} resource that points to the {\bf
Device} resources.  You must also specify a
{\bf Changer Device}.  If the Autochanger directive is set to {\bf
No} (default), the volume must be manually changed.  You should also
have an identical directive to the
\ilink{Storage resource}{Autochanger1}  in the Director's
configuration file so that  when labeling tapes you are prompted for the slot.

\item [Changer Device = {\textless}name-string{\textgreater}] \hfill \\
\index[sd]{Changer Device}
\index[sd]{Directive!Changer Device}
The specified {\bf name-string} must be the {\bf generic SCSI} device
name of the autochanger that corresponds to the normal read/write
{\bf Archive Device}  specified in the Device resource. This
generic SCSI device name should be specified if you have an autochanger
or if you have a standard tape drive and want to use the
{\bf Alert Command} (see below). For example, on Linux systems, for
an Archive Device name of {\bf /dev/nst0}, you would specify {\bf
/dev/sg0} for the Changer Device name. Depending on your exact
configuration, and the number of autochangers or the type of
autochanger, what you specify here can vary.  This directive is
optional.  See the \ilink{ Using Autochangers}{AutochangersChapter} chapter
of this manual for more details of using this and the following
autochanger directives.

\item [Changer Command = {\textless}name-string{\textgreater}] \hfill \\
\index[sd]{Changer Command}
\index[sd]{Directive!Changer Command}
The {\bf name-string} specifies an external program to be called  that will
automatically change volumes as required by {\bf Bareos}.  Normally,
this directive will be specified only in the {\bf AutoChanger} resource,
which is then used for all devices.  However, you may also specify
the different {\bf Changer Command} in each Device resource.
Most frequently,
you will specify the Bareos supplied {\bf mtx-changer}  script as follows:

\footnotesize
\begin{verbatim}
Changer Command = "/usr/lib/bareos/scripts/mtx-changer %c %o %S %a %d"
\end{verbatim}
\normalsize

and you will install the {\bf mtx} on your system.
An example of this command is in the default \file|bareos-sd.conf| file.
For more details on the substitution characters that may be specified  to
configure your autochanger please see  the
\ilink{Autochangers}{AutochangersChapter} chapter of this  manual.

\item [Alert Command = {\textless}name-string{\textgreater}] \hfill \\
\index[sd]{Alert Command}
The {\bf name-string} specifies an external program to be called at the
completion of each Job after the device is released.  The purpose of this
command is to check for Tape Alerts, which are present when something is
wrong with your tape drive (at least for most modern tape drives).  The same
substitution characters that may be specified in the Changer Command may
also be used in this string.  For more information, please see the
\ilink{Autochangers}{AutochangersChapter} chapter of this manual.

Note, it is not necessary to have an autochanger to use this command. The
example below uses the {\bf tapeinfo} program that comes with the {\bf mtx}
package, but it can be used on any tape drive. However, you will need to
specify a {\bf Changer Device} directive in your Device resource (see above)
so that the generic SCSI device name can be edited into the command (with
the \%c).

An example of the use of this command to print Tape Alerts  in the Job report
is:

\footnotesize
\begin{verbatim}
Alert Command = "sh -c 'tapeinfo -f %c | grep TapeAlert'"

\end{verbatim}
\normalsize

and an example output when there is a problem could be:

\footnotesize
\begin{verbatim}
bareos-sd  Alert: TapeAlert[32]: Interface: Problem with SCSI interface
                  between tape drive and initiator.

\end{verbatim}
\normalsize

\item [Drive Index = {\textless}number{\textgreater}] \hfill \\
\index[sd]{Drive Index}
\index[sd]{Directive!Drive Index}
The {\bf Drive Index} that you specify is passed to the {\bf
mtx-changer} script and is thus passed to the {\bf mtx} program.  By
default, the Drive Index is zero, so if you have only one drive in your
autochanger, everything will work normally.  However, if you have
multiple drives, you must specify multiple Bareos Device resources (one
for each drive).  The first Device should have the Drive Index set to 0,
and the second Device Resource should contain a Drive Index set to 1,
and so on.  This will then permit you to use two or more drives in your
autochanger.

\item [Autoselect = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Autoselect}
\index[sd]{Directive!Autoselect}
If this directive is set to {\bf yes} (default), and the Device
belongs to an autochanger, then when the Autochanger is referenced
by the Director, this device can automatically be selected. If this
directive is set to {\bf no}, then the Device can only be referenced
by directly using the Device name in the Director. This is useful
for reserving a drive for something special such as a high priority
backup or restore operations.

\directive{sd}{Maximum Concurrent Jobs}{number}{}{}{}
{\bf Maximum Concurrent Jobs} is a directive that permits setting the maximum
number of Jobs that can run concurrently on a specified Device.  Using this
directive, it is possible to have different Jobs using multiple drives, because
when the Maximum Concurrent Jobs limit is reached, the Storage Daemon will
start new Jobs on any other available compatible drive.  This facilitates
writing to multiple drives with multiple Jobs that all use the same Pool.

\item [Maximum Changer Wait = {\textless}time{\textgreater}] \hfill \\
\index[sd]{Maximum Changer Wait}
\index[sd]{Directive!Maximum Changer Wait}
This directive specifies the maximum time in seconds for Bareos to wait
for an autochanger to change the volume.  If this time is exceeded,
Bareos will invalidate the Volume slot number stored in the catalog and
try again.  If no additional changer volumes exist, Bareos will ask the
operator to intervene.  The default is 5 minutes.
% TODO: if this is the format, then maybe "5 minutes" should be in
% TODO: quotes? define style. see others.

\item [Maximum Rewind Wait = {\textless}time{\textgreater}] \hfill \\
\index[sd]{Maximum Rewind Wait}
\index[sd]{Directive!Maximum Rewind Wait}
This directive specifies the maximum time in seconds for Bareos to wait
for a rewind before timing out.  If this time is exceeded,
Bareos will cancel the job.  The default is 5 minutes.

\item [Maximum Open Wait = {\textless}time{\textgreater}] \hfill \\
\index[sd]{Maximum Open Wait}
\index[sd]{Directive!Maximum Open Wait}
This directive specifies the maximum time in seconds for Bareos to wait
for a open before timing out.  If this time is exceeded,
Bareos will cancel the job.  The default is 5 minutes.

\directive{sd}{Always Open}{yes{\textbar}no}{}{no}{}
If {\bf Yes}, Bareos will always keep the device open unless
specifically {\bf unmounted} by the Console program.  This permits
Bareos to ensure that the tape drive is always available, and properly
positioned. If you set
{\bf AlwaysOpen} to {\bf no} {\bf Bareos} will only open the
drive when necessary, and at the end of the Job if no other Jobs are
using the drive, it will be freed.  The next time Bareos wants to append
to a tape on a drive that was freed, Bareos will rewind the tape and
position it to the end.  To avoid unnecessary tape positioning and to
minimize unnecessary operator intervention, it is highly recommended
that {\bf Always Open = yes}.  This also ensures that the drive is
available when Bareos needs it.

If you have {\bf Always Open = yes} (recommended) and you want to use the
drive for something else, simply use the {\bf unmount} command in the
Console program to release the drive. However, don't forget to remount the
drive with {\bf mount} when the drive is available or the next Bareos job
will block.

For File storage, this directive is ignored. For a FIFO storage  device, you
must set this to {\bf No}.

Please note that if you set this directive to {\bf No} Bareos  will release
the tape drive between each job, and thus the next job  will rewind the tape
and position it to the end of the data. This  can be a very time consuming
operation. In addition, with this directive set to no, certain multiple
drive autochanger operations will fail.  We strongly recommend to keep
{\bf Always Open} set to {\bf Yes}


\item [Volume Poll Interval = {\textless}time{\textgreater}] \hfill \\
\index[sd]{Volume Poll Interval}
\index[sd]{Directive!Volume Poll Interval}
If the time  specified on this directive is non-zero, after  asking the
operator to mount a new volume Bareos will  periodically poll (or read) the
drive at the specified  interval to see if a new volume has been mounted. If
the  time interval is zero (the default), no polling will occur.  This
directive can be useful if you want to avoid operator  intervention via the
console. Instead, the operator can  simply remove the old volume and insert
the requested one,  and Bareos on the next poll will recognize the new tape
and  continue. Please be aware that if you set this interval  too small, you
may excessively wear your tape drive if the  old tape remains in the drive,
since Bareos will read it on  each poll. This can be avoided by ejecting the
tape using  the {\bf Offline On Unmount} and the {\bf Close on Poll}
directives.
However, if you are using a Linux 2.6 kernel or other OSes
such as FreeBSD or Solaris, the Offline On Unmount will leave the drive
with no tape, and Bareos will not be able to properly open the drive and
may fail the job.
%\TODO{reference is missing:  For more information on this problem, please see the
%\ilink{description of Offline On Unmount}{NoTapeInDrive} in the Tape
%Testing chapter.}

\item [Close on Poll= {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Close on Poll}
\index[sd]{Directive!Close on Poll}
If {\bf Yes}, Bareos close the device (equivalent to  an unmount except no
mount is required) and reopen it at each  poll. Normally this is not too
useful unless you have the  {\bf Offline on Unmount} directive set, in which
case the  drive will be taken offline preventing wear on the tape  during any
future polling. Once the operator inserts a new  tape, Bareos will recognize
the drive on the next poll and  automatically continue with the backup.
Please see above for more details.

\item [Maximum Open Wait = {\textless}time{\textgreater}] \hfill \\
\index[sd]{Maximum Open Wait}
\index[sd]{Directive!Maximum Open Wait}
This directive specifies the maximum amount of time in seconds that
Bareos will wait for a device that is busy.  The default is 5 minutes.
If the device cannot be obtained, the current Job will be terminated in
error.  Bareos will re-attempt to open the drive the next time a Job
starts that needs the the drive.

\label{removablemedia}
\item [Removable media = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Removable media}
\index[sd]{Directive!Removable media}
If {\bf Yes}, this device supports removable media (for example, tapes
or CDs).  If {\bf No}, media cannot be removed (for example, an
intermediate backup area on a hard disk). If {\bf Removable media} is
enabled on a File device (as opposed to a tape) the Storage daemon will
assume that device may be something like a USB device that can be
removed or a simply a removable harddisk. When attempting to open
such a device, if the Volume is not found (for File devices, the Volume
name is the same as the Filename), then the Storage daemon will search
the entire device looking for likely Volume names, and for each one
found, it will ask the Director if the Volume can be used.  If so,
the Storage daemon will use the first such Volume found.  Thus it
acts somewhat like a tape drive -- if the correct Volume is not found,
it looks at what actually is found, and if it is an appendable Volume,
it will use it.

If the removable medium is not automatically mounted (e.g. udev), then
you might consider using additional Storage daemon device directives
such as {\bf Requires Mount}, {\bf Mount Point}, {\bf Mount Command},
and {\bf Unmount Command}, all of which can be used in conjunction with
{\bf Removable Media}.

\item [Random access = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Random access}
\index[sd]{Directive!Random access}
If {\bf Yes}, the archive device is assumed to be a random access medium
which supports the {\bf lseek} (or {\bf lseek64} if Largefile is enabled
during configuration) facility. This should be set to {\bf Yes} for all
file systems such as USB, and fixed files.  It should be set to
{\bf No} for non-random access devices such as tapes and named pipes.

\item [Requires Mount = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Requires Mount}
When this directive is enabled, the Storage daemon will submit
a {\bf Mount Command} before attempting to open the device.
You must set this directive to {\bf yes} for removable
file systems such as USB devices that are not automatically mounted
by the operating system when plugged in or opened by Bareos.
It should be set to {\bf no} for
all other devices such as tapes and fixed filesystems. It should also
be set to {\bf no} for any removable device that is automatically
mounted by the operating system when opened (e.g. USB devices mounted
by udev or hotplug). This directive
indicates if the device requires to be mounted using the {\bf Mount
Command}.  To be able to write devices need a mount, the following
directives must also be defined: {\bf Mount Point}, {\bf Mount Command},
and {\bf Unmount Command}.

\item [Mount Point = {\textless}directory{\textgreater}] \hfill \\
\index[sd]{Mount Point}
Directory where the device can be mounted.
This directive is used only
for devices that have {\bf Requires Mount} enabled such as
USB file devices.

\item [Mount Command = {\textless}name-string{\textgreater}] \hfill \\
\index[sd]{Mount Command}
This directive specifies the command that must be executed to mount
devices such as many USB devices. Before the command is
executed, \%a is replaced with the Archive Device, and \%m with the Mount
Point.

See the \ilink {Edit Codes}{mountcodes} section below for more details of
the editing codes that can be used in this directive.

If you need to specify multiple commands, create a shell script.

\item [Unmount Command = {\textless}name-string{\textgreater}] \hfill \\
\index[sd]{Unmount Command}
This directive specifies the command that must be executed to unmount
devices such as many USB devices. Before the command  is
executed, \%a is replaced with the Archive Device, and \%m with the  Mount
Point.

Most frequently, you will define it as follows:

\footnotesize
\begin{verbatim}
  Unmount Command = "/bin/umount %m"
\end{verbatim}
\normalsize

See the \ilink {Edit Codes}{mountcodes} section below for more details of
the editing codes that can be used in this directive.

If you need to specify multiple commands, create a shell script.

\item [Label Media = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[general]{Label Media}
\index[sd]{Label Media}
\index[sd]{Directive!Label Media}
If {\bf Yes}, permits this device to automatically label blank media
without an explicit operator command.  It does so by using an internal
algorithm as defined on the \ilink{Label Format}{Label} record in each
Pool resource.  If this is {\bf No} as by default, Bareos will label
tapes only by specific operator command ({\bf label} in the Console) or
when the tape has been recycled.  The automatic labeling feature is most
useful when writing to disk rather than tape volumes.

\item [Automatic Mount = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Automatic mount}
\index[sd]{Directive!Automatic mount}
If {\bf Yes} (the default), permits the daemon to examine the device to
determine if it contains a Bareos labeled volume.  This is done
initially when the daemon is started, and then at the beginning of each
job.  This directive is particularly important if you have set
{\bf Always Open = no} because it permits Bareos to attempt to read the
device before asking the system operator to mount a tape.  However,
please note that the tape must be mounted before the job begins.


\directive{sd}{Block Checksum}{yes{\textbar}no}{}{yes}{}
You may turn off the Block Checksum (CRC32) code that Bareos uses when
writing blocks to a Volume. Doing so can reduce the Storage daemon CPU usage
slightly.  It will also permit Bareos to read a Volume that has corrupted
data.

\textbf{We do not recommend to turn this off} particularly on older tape
drives or for disk Volumes where doing so may allow corrupted data to go
undetected.

\directive{sd}{Minimum block size}{size-in-bytes}{}{0}{}
This statement applies only to non-random access devices (e.g.
tape drives).  Blocks written by the storage daemon to a non-random
archive device will never be smaller than the given {\bf size-in-bytes}.
The Storage daemon will attempt to efficiently fill blocks with data
received from active sessions but will, if necessary, add padding to a
block to achieve the required minimum size.

To force the block size to be fixed, as is the case for some non-random
access devices (tape drives), set the {\bf Minimum block size} and the
{\bf Maximum block size} to the same value.  The default
is that both the minimum and maximum block size are zero and the default
block size is 64,512 bytes.

For  example, suppose you want a fixed block size of 100K bytes, then you
would specify:

\begin{bconfig}{Fixed Block Size}
Minimum block size = 100K
Maximum block size = 100K
\end{bconfig}

Please note that if you specify a fixed block size as shown above,  the tape
drive must either be in variable block size mode, or  if it is in fixed block
size mode, the block size (generally  defined by \command{mt}) {\bf must} be
identical to the size specified  in Bareos -- otherwise when you attempt to
re-read your Volumes,  you will get an error.

If you want the  block size to be variable but with a 64K minimum and 200K
maximum (and  default as well), you would specify:

\begin{bconfig}{Variable Block Size}
Minimum block size =  64K
Maximum block size = 200K
\end{bconfig}


\directive{sd}{Maximum block size}{size-in-bytes}{}{64512}{}
The Storage daemon will always attempt to
write blocks of the specified {\bf size-in-bytes} to the archive device.
As a consequence, this statement specifies both the default block size
and the maximum block size.  The size written never exceed the given
{\bf size-in-bytes}.  If adding data to a block would cause it to exceed
the given maximum size, the block will be written to the archive device,
and the new data will begin a new block.

If no value is specified or zero is specified, the Storage daemon will
use a default block size of 64,512 bytes (126 * 512).

This default size is far too low for modern tape drives. If you
are using a modern tape drive like LTO-4 or newer, you should use
a block size of 512k or 1M.

For more information, please see the tape speed whitepaper:
\elink{http://www.bareos.org/en/Whitepapers/articles/Speed\_Tuning\_of\_Tape\_Drives.html}{http://www.bareos.org/en/Whitepapers/articles/Speed\_Tuning\_of\_Tape\_Drives.html}

%The maximum {\bf size-in-bytes} possible is 2,000,000.

\warning{If your are using LTO drives, changing the block size after labeling the tape will result into unreadable tapes. So normally you will not change the block size in an existing configuration.}

\directive{sd}{Label block size}{size-in-bytes}{}{64512}{}
The storage daemon will write the label blocks with the size configured here.
Usually, you will not need to change this directive.

For more information on this directive, please see \ilink{Tapespeed and blocksizes}{Tapespeed and blocksizes}.


\directive{sd}{Hardware End of Medium}{yes{\textbar}no}{}{yes}{}
All modern (after 1998) tape drives should support this
feature. In doubt, use the {\bf btape} program  to test your drive to see whether or not it
supports this function.
If the archive device does not support the end of medium
ioctl request {\tt MTEOM}, set this parameter to {\bf No}.
The storage daemon will then use the forward space file
function to find the end of the recorded data.
In addition, your SCSI driver must
keep track of the file number on the tape and report it back correctly by
the {\bf MTIOCGET} ioctl. Note, some SCSI drivers will correctly forward
space to the end of the recorded data, but they do not keep track of the
file number.  On Linux machines, the SCSI driver has a {\bf fast-eod}
option, which if set will cause the driver to lose track of the file
number. You should ensure that this option is always turned off using the
{\bf mt} program.

\directive{sd}{Fast Forward Space File}{yes{\textbar}no}{}{yes}{}
If {\bf No}, the archive device is not required to support  keeping track of
the file number ({\bf MTIOCGET} ioctl) during  forward space file. If {\bf
Yes}, the archive device must support  the {\tt ioctl} {\tt MTFSF} call, which
virtually all drivers  support, but in addition, your SCSI driver must keep
track of the  file number on the tape and report it back correctly by the
{\bf MTIOCGET} ioctl. Note, some SCSI drivers will correctly  forward space,
but they do not keep track of the file number or more  seriously, they do not
report end of medium.

\directive{sd}{Use MTIOCGET}{yes{\textbar}no}{}{yes}{}
If {\bf No}, the operating system is not required to support keeping track of
the file number and reporting it in the ({\bf MTIOCGET} ioctl).
If you must set this to No, Bareos will do the proper file
position determination, but it is very unfortunate because it means that
tape movement is very inefficient.
Fortunately, this operation system deficiency seems to be the case only
on a few *BSD systems.  Operating systems known to work correctly are
Solaris, Linux and FreeBSD.

\directive{sd}{BSF at EOM}{yes{\textbar}no}{}{no}{}
If {\bf No}, the default, no special action is taken by Bareos with the End
of Medium (end of tape) is reached because the tape will be positioned after
the last EOF tape mark, and Bareos can append to the tape as desired.
However, on some systems, such as FreeBSD, when Bareos reads the End of
Medium (end of tape), the tape will be positioned after the second EOF tape
mark (two successive EOF marks indicated End of Medium). If Bareos appends
from that point, all the appended data will be lost. The solution for such
systems is to specify {\bf BSF at EOM} which causes Bareos to backspace over
the second EOF mark. Determination of whether or not you need this directive
is done using the {\bf test} command in the {\bf btape} program.

\directive{sd}{Two EOF}{yes{\textbar}no}{}{no}{}
If {\bf Yes}, Bareos will write two end of file marks when terminating a
tape -- i.e. after the last job or at the end of the medium. If {\bf No},
the default, Bareos will only write one end of file to terminate the tape.

\item [Backward Space Record = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Backward Space Record}
\index[sd]{Directive!Backward Space Record}
If {\bf Yes}, the archive device supports the {\tt MTBSR ioctl} to backspace
records. If {\bf No}, this call is not used and the device must be rewound
and advanced forward to the desired position. Default is {\bf Yes} for non
random-access devices. This function if enabled is used at the end of a
Volume after writing the end of file and any ANSI/IBM labels to determine
whether or not the last block was written correctly. If you turn this
function off, the test will not be done. This causes no harm as the re-read
process is precautionary rather than required.

\item [Backward Space File = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Backward Space File}
\index[sd]{Directive!Backward Space File}
If {\bf Yes}, the archive device supports the {\bf MTBSF} and  {\bf MTBSF
  ioctl}s to backspace over an end of file mark and to the  start of a file. If
  {\bf No}, these calls are not used and the  device must be rewound and
  advanced forward to the desired position.  Default is {\bf Yes} for non
  random-access devices.

\item [Forward Space Record = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Forward Space Record}
\index[sd]{Directive!Forward Space Record}
If {\bf Yes}, the archive device must support the {\bf MTFSR  ioctl} to
forward space over records. If {\bf No}, data must  be read in order to
advance the position on the device. Default is  {\bf Yes} for non
random-access devices.

\item [Forward Space File = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Forward Space File}
\index[sd]{Directive!Forward Space File}
If {\bf Yes}, the archive device must support the {\tt MTFSF  ioctl} to
forward space by file marks. If {\bf No}, data  must be read to advance the
position on the device. Default is  {\bf Yes} for non random-access devices.

\item [Offline On Unmount = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Offline On Unmount}
\index[sd]{Directive!Offline On Unmount}
The default for this directive is {\bf No}. If {\bf Yes} the  archive device
must support the {\tt MTOFFL ioctl} to rewind and  take the volume offline. In
this case, Bareos will issue the  offline (eject) request before closing the
device during the {\bf unmount}  command. If {\bf No} Bareos will not attempt
to offline the  device before unmounting it. After an offline is issued,  the
cassette will be ejected thus {\bf requiring operator intervention}  to
continue, and on some systems require an explicit load command  to be issued
({\bf mt -f /dev/xxx load}) before the system will recognize  the tape. If you
are using an autochanger, some devices  require an offline to be issued prior
to changing the volume. However,  most devices do not and may get very
confused.

If you are using a Linux 2.6 kernel or other OSes
such as FreeBSD or Solaris, the Offline On Unmount will leave the drive
with no tape, and Bareos will not be able to properly open the drive and
may fail the job.
%\TODO{missing reference:  For more information on this problem, please see the
%\ilink{description of Offline On Unmount}{NoTapeInDrive} in the Tape
%Testing chapter.}

\item [No Rewind On Close = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{No Rewind On Close}
\index[sd]{Directive!No Rewind On Close}
The default for this directive is {\bf No}. If {\bf Yes} the storage daemon
will not try to rewind the device on closing the device e.g. when shutting
down the Storage daemon. This allows you to do an emergency shutdown of
the Daemon without the need to wait for the device to rewind. On restarting
and opening the device it will get a rewind anyhow and this way services
don't have to wait forever for a tape to spool back.

\item [Drive Crypto Enabled = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Drive Crypto Enabled}
\index[sd]{Directive!Drive Crypto Enabled}
The default for this directive is {\bf No}. If {\bf Yes} the storage daemon
can perform so called Application Managed Encryption (AME) using a special
Storage Daemon plugin which loads and clears the Encryption key using the
SCSI SPIN/SPOUT protocol.

\item [Query Crypto Status = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Query Crypto Status}
\index[sd]{Directive!Query Crypto Status}
The default for this directive is {\bf No}. If {\bf Yes} the storage daemon
may query the tape device for it security status. This only makes sense when
Drive Crypto Enabled is also set to {\bf yes} as the actual query is performed
by the same Storage Daemon plugin and using the same SCSI SPIN protocol.

\item [Maximum Concurrent Jobs = {\textless}number{\textgreater}] \hfill \\
\index[sd]{Device Maximum Concurrent Jobs}
\index[sd]{Directive!Device Maximum Concurrent Jobs}
\index[sd]{Directive!New in 3.0.3}
where {\textless}number{\textgreater} is the maximum number of Jobs that can run
concurrently on a specified Device.  Using this directive, it is possible
to have different Jobs using multiple drives, because when
the Maximum Concurrent Jobs limit is
reached, the Storage Daemon will start new Jobs on any other available
compatible drive.  This facilitates writing to multiple drives with
multiple Jobs that all use the same Pool.

\item [Maximum Volume Size = {\textless}size{\textgreater}] \hfill \\
\index[sd]{Maximum Volume Size}
\index[sd]{Directive!Maximum Volume Size}
No more than {\bf size} bytes will be written onto a given volume on the
archive device.  This directive is used mainly in testing Bareos to
simulate a small Volume.  It can also be useful if you wish to limit the
size of a File Volume to say less than 2GB of data.  In some rare cases
of really antiquated tape drives that do not properly indicate when the
end of a tape is reached during writing (though I have read about such
drives, I have never personally encountered one).  Please note, this
directive is deprecated (being phased out) in favor of the {\bf Maximum
Volume Bytes} defined in the Director's configuration file.

\item [Maximum File Size = {\textless}size{\textgreater}] \hfill \\
\index[sd]{Maximum File Size}
\index[sd]{Directive!Maximum File Size}
No more than {\bf size} bytes will be written into a given logical file
on the volume.  Once this size is reached, an end of file mark is
written on the volume and subsequent data are written into the next
file.  Breaking long sequences of data blocks with file marks permits
quicker positioning to the start of a given stream of data and can
improve recovery from read errors on the volume.  The default is one
Gigabyte.  This directive creates EOF marks only on tape media.
However, regardless of the medium type (tape, disk, USB ...) each time
a the Maximum File Size is exceeded, a record is put into the catalog
database that permits seeking to that position on the medium for
restore operations. If you set this to a small value (e.g. 1MB),
you will generate lots of database records (JobMedia) and may
significantly increase CPU/disk overhead.

If you are configuring an modern drive like LTO-4 or newer, you probably will
want to set the {\bf Maximum File Size} to 20GB or bigger to avoid making
the drive stop to write an EOF mark.

For more info regarding this parameter, read the tape speed whitepaper:
\elink{http://www.bareos.org/en/Whitepapers/articles/Speed\_Tuning\_of\_Tape\_Drives.html}{http://www.bareos.org/en/Whitepapers/articles/Speed\_Tuning\_of\_Tape\_Drives.html}

Note, this directive does not limit the size of Volumes that Bareos
will create regardless of whether they are tape or disk volumes. It
changes only the number of EOF marks on a tape and the number of
block positioning records (see below) that are generated. If you
want to limit the size of all Volumes for a particular device, use
the {\bf Maximum Volume Size} directive (above), or use the
{\bf Maximum Volume Bytes} directive in the Director's Pool resource,
which does the same thing but on a Pool (Volume) basis.

\item [Block Positioning = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Block Positioning}
\index[sd]{Directive!Block Positioning}
This directive tells Bareos not to use block positioning when doing restores.
Turning this directive off can cause Bareos to be {\bf extremely} slow
when restoring files.  You might use this directive if you wrote your
tapes with Bareos in variable block mode (the default), but your drive
was in fixed block mode. The default is {\bf yes}.


\item [Maximum Network Buffer Size = {\textless}bytes{\textgreater}] \hfill \\
\index[sd]{Maximum Network Buffer Size}
\index[sd]{Directive!Maximum Network Buffer Size}
where {\bf bytes} specifies the initial network buffer  size to use with the
File daemon.  This size will be adjusted down if it is too large until
it is accepted by the OS. Please use care in setting this value since if
it is too large, it will be trimmed by 512 bytes until the OS is happy,
which may require a large number of system calls.  The default value is
32,768 bytes.

The default size was chosen to be relatively large but not too big in
the case that you are transmitting data over Internet.  It is clear that
on a high speed local network, you can increase this number and improve
performance. For example, some users have found that if you use a value
of 65,536 bytes they get five to ten times the throughput.  Larger values for
most users don't seem to improve performance. If you are interested
in improving your backup speeds, this is definitely a place to
experiment. You will probably also want to make the corresponding change
in each of your File daemons conf files.

\item [Maximum Spool Size = {\textless}bytes{\textgreater}] \hfill \\
\index[sd]{Maximum Spool Size}
\index[sd]{Directive!Maximum Spool Size}
where the bytes specify the maximum spool size for all jobs that are
running.  The default is no limit.

\item [Maximum Job Spool Size = {\textless}bytes{\textgreater}] \hfill \\
\index[sd]{Maximum Job Spool Size}
\index[sd]{Directive!Maximum Job Spool Size}
where the bytes specify the maximum spool size for any one job  that is
running. The default is no limit.

\item [Spool Directory = {\textless}directory{\textgreater}] \hfill \\
\index[sd]{Spool Directory}
\index[sd]{Directive!Spool Directory}
specifies the name of the directory to be used to store  the spool files for
this device. This directory is also used to store  temporary part files when
writing to a device that requires mount (USB).  The default is to use the
working directory.

\xdirective{sd}{AutoDeflate}{in{\textbar}out{\textbar}both}{}{}{13.4}{This is a parameter used by the autoxflate-sd plugin which allow you to transform
a non compressed piece of data into a compressed piece of data on the storage daemon.
e.g. Storage Daemon compression. You can either enable compression on the client
and use the CPU cyclces there to compress your data with one of the supported
compression algorithms. The value of this parameter specifies a so called io-direction
currently you can use the following io-directions:

\begin{itemize}
\item in - compress data streams while reading the data from a device.
\item out - compress data streams while writing the data to a device.
\item both - compress data streams both when reading and writing to a device.
\end{itemize}

Currently only plain data streams are compressed (so things that are already
compressed or encrypted will not be considered for compression.) Also meta-data
streams are not compressed. The compression is done in a way that the stream is
transformed into a native compressed data stream. So if you enable this and
send the data to a filedaemon it will know its a compressed stream and will
do the decompression itself. This also means that you can turn this option on
and off at any time without having any problems with data already written.

This option could be used if your clients doesn't have enough power to do
the compression/decompression itself and you have enough network bandwidth.
Or when your filesystem doesn't have the option to transparently compress
data you write to it but you want the data to be compressed when written.
}

\xdirective{sd}{AutoDeflateAlgorithm}{GZIP{\textbar}LZO{\textbar}LZFAST{\textbar}LZ4{\textbar}LZ4HC}{}{}{13.4}{This option specifies the compression algorithm used for the autodeflate option
which is performed by the autoxflate-sd plugin. The algorithms supported are:
\begin{itemize}
\item GZIP - gzip level 1--9
\item LZO
\item LZFAST
\item LZ4
\item LZ4HC
\end{itemize}}

\xdirective{sd}{AutoDeflateLevel}{0--9}{}{}{13.4}{This option specifies the level to be used when compressing when you select a
compression algorithm that has different levels.}

\xdirective{sd}{AutoInflate}{in{\textbar}out{\textbar}both}{}{}{13.4}{This is a parameter used by the autoxflate-sd plugin which allow you to transform
a compressed piece of data into a non compressed piece of data on the storage daemon.
e.g. Storage Daemon decompression. You can either enable decompression on the client
and use the CPU cyclces there to decompress your data with one of the supported
compression algorithms. The value of this parameter specifies a so called io-direction
currently you can use the following io-directions:

\begin{itemize}
\item in - decompress data streams while reading the data from a device.
\item out - decompress data streams while writing the data to a device.
\item both - decompress data streams both when reading and writing to a device.
\end{itemize}

This option allows you to write uncompressed data to for instance a tape drive
that has hardware compression even when you compress your data on the client with
for instance a low cpu load compression method (LZ4 for instance) to transfer
less data over the network. It also allows you to restore data in a compression
format that the client might not support but the storage daemon does. This only
works on normal compressed datastreams not on encrypted datastreams or meta data
streams.}
\end{description}

\subsection{Edit Codes for Mount and Unmount Directives}
\index[general]{Directives!Edit Codes}
\index[general]{Edit Codes for Mount and Unmount Directives}
\label{mountcodes}

Before submitting the {\bf Mount Command}, or {\bf Unmount Command}
directives to the operating system, Bareos performs character substitution
of the following characters:

\footnotesize
\begin{verbatim}
    %% = %
    %a = Archive device name
    %e = erase (set if cannot mount and first part)
    %n = part number
    %m = mount point
    %v = last part name (i.e. filename)
\end{verbatim}
\normalsize

\subsection{Devices that require a mount (USB)}
\index[general]{Devices that require a mount (USB)}

\begin{description}
\item [Requires Mount = {\textless}yes{\textbar}no{\textgreater}] \hfill \\
\index[sd]{Requires Mount}
\index[sd]{Directive!Requires Mount}
You must set this directive to {\bf yes} for removable devices such as
USB unless they are automounted, and to {\bf no} for all other devices
(tapes/files).  This directive indicates if the device requires to be
mounted to be read, and if it must be written in a special way.  If it
set, {\bf Mount Point}, {\bf Mount Command}, and {\bf Unmount Command}
directives must also be defined.

\item [Mount Point = {\textless}directory{\textgreater}] \hfill \\
\index[sd]{Mount Point}
\index[sd]{Directive!Mount Point}
Directory where the device can be mounted.

\item [Mount Command = {\textless}name-string{\textgreater}] \hfill \\
\index[sd]{Mount Command}
\index[sd]{Directive!Mount Command}
Command that must be executed to mount the device. Before the command is
executed, \%a is replaced with the Archive Device, and \%m with the Mount
Point.

Most frequently, you will define it as follows:

\footnotesize
\begin{verbatim}
  Mount Command = "/bin/mount -t iso9660 -o ro %a %m"
\end{verbatim}
\normalsize

For some media, you may need multiple commands.  If so, it is recommended
that you use a shell script instead of putting them all into the Mount
Command.  For example, instead of this:

\footnotesize
\begin{verbatim}
  Mount Command = "/usr/local/bin/mymount"
\end{verbatim}
\normalsize

Where that script contains:

\footnotesize
\begin{verbatim}
#!/bin/sh
ndasadmin enable -s 1 -o w
sleep 2
mount /dev/ndas-00323794-0p1 /backup
\end{verbatim}
\normalsize

Similar consideration should be given to all other Command parameters.

\item [Unmount Command = {\textless}name-string{\textgreater}] \hfill \\
\index[sd]{Unmount Command}
\index[sd]{Directive!Unmount Command}
Command that must be executed to unmount the device. Before the command  is
executed, \%a is replaced with the Archive Device, and \%m with the  Mount
Point.

Most frequently, you will define it as follows:

\footnotesize
\begin{verbatim}
  Unmount Command = "/bin/umount %m"
\end{verbatim}
\normalsize

  If you need to specify multiple commands, create a shell script.

\end{description}

%% This pulls in the Autochanger resource from another file.
\input{storedconf-autochangerres}



\section{Messages Resource}
\label{MessagesResource1}
\index[general]{Resource!Messages}
\index[general]{Messages Resource}

For a description of the Messages Resource, please see the
\ilink{Messages Resource}{MessagesChapter} Chapter of this
manual.

\section{Example Storage Daemon Configuration File}
\label{ExampleStorageConfiguration}
\index[general]{File!Example Storage Daemon Configuration}
\index[general]{Configuration!Storage Daemon}


A example Storage Daemon configuration file might be the following:

\footnotesize
\verbatimtabinput[4]{bareos-sd.conf}
\normalsize
